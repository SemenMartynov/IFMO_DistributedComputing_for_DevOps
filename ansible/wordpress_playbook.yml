- name: Deploy WordPress
  hosts: all
  become: true
  vars:
    docker_compose_path: "/opt/wordpress"
    wordpress_db_name: "wordpress"
    wordpress_db_user: "wp_user"
    wordpress_db_password: "wp_password"
    wordpress_db_root_password: "rootpassword"
    repl_user: "repl"
    repl_password: "replpass"
  tasks:
    - name: Install required packages
      apt:
        name:
          - docker.io
          - docker-compose
          - ufw
        state: present
        update_cache: yes

    - name: Enable and start Docker service
      systemd:
        name: docker
        enabled: yes
        state: started

    - name: Create Docker Compose directory
      file:
        path: "{{ docker_compose_path }}"
        state: directory
        mode: '0755'

    - name: Copy Docker Compose file
      copy:
        src: docker-compose.yml
        dest: "{{ docker_compose_path }}/docker-compose.yml"
        mode: '0644'

    - name: Copy Nginx Config File
      copy:
        src: nginx.conf
        dest: "{{ docker_compose_path }}/nginx.conf"
        mode: '0644'

    - name: Copy master.conf
      copy:
        src: master.conf
        dest: "{{ docker_compose_path }}/master.conf"

    - name: Copy replica.conf
      copy:
        src: replica.conf
        dest: "{{ docker_compose_path }}/replica.conf"

    - name: Dump existing WordPress database
      shell: |
        docker exec wordpress_db sh -c "exec mysqldump -u root -p {{ root_password }} wordpress" > "{{ docker_compose_path }}/wordpress.sql"
      args:
        executable: /bin/bash

    - name: Stop and remove existing containers (if any)
      shell: "docker-compose down"
      args:
        chdir: "{{ docker_compose_path }}"
      ignore_errors: true

    - name: Start Docker Compose
      shell: "docker-compose up -d"
      args:
        chdir: "{{ docker_compose_path }}"

    - name: Wait for master to be ready
      shell: docker exec mysql_master mysqladmin ping -u root -p {{ root_password }}
      register: result
      retries: 10
      delay: 5
      until: result.rc == 0

    - name: Copy dump file into mysql_master container
      shell: |
        docker cp "{{ docker_compose_path }}/wordpress.sql" mysql_master:/wordpress.sql

    - name: Import dump into mysql_master
      shell: |
        docker exec mysql_master sh -c "mysql -u root -p {{ root_password }} wordpress < /wordpress.sql"
      args:
        executable: /bin/bash

    - name: Create replication user on master
      shell: |
        docker exec mysql_master mysql -u root -p {{ root_password }} -e "\
        CREATE USER IF NOT EXISTS '{{ repl_user }}'@'%' IDENTIFIED BY '{{ repl_password }}'; \
        GRANT REPLICATION SLAVE ON *.* TO '{{ repl_user }}'@'%'; \
        FLUSH PRIVILEGES;"
      changed_when: true

    - name: Get master status
      shell: |
        docker exec mysql_master mysql -u root -p {{ root_password }} -e "SHOW MASTER STATUS\G"
      register: master_status_output

    - name: Parse master status
      set_fact:
        master_log_file: "{{ master_status_output.stdout | regex_search('File: (.*)', '\\1') }}"
        master_log_pos: "{{ master_status_output.stdout | regex_search('Position: (\\d+)', '\\1') | int }}"

    - name: Wait for replica to be ready
      shell: docker exec mysql_replica mysqladmin ping -u root -p {{ root_password }}
      register: result
      retries: 10
      delay: 5
      until: result.rc == 0

    - name: Configure replication on replica
      shell: |
        docker exec mysql_replica mysql -u root -p {{ root_password }} -e "\
        STOP SLAVE; \
        CHANGE MASTER TO \
          MASTER_HOST='mysql_master', \
          MASTER_USER='{{ repl_user }}', \
          MASTER_PASSWORD='{{ repl_password }}', \
          MASTER_LOG_FILE='{{ master_log_file }}', \
          MASTER_LOG_POS={{ master_log_pos }}, \
          GET_MASTER_PUBLIC_KEY = 1; \
        START SLAVE;"
      changed_when: true

    - name: Check slave status
      shell: docker exec mysql_replica mysql -u root -p {{ root_password }} -e "SHOW SLAVE STATUS\G"
      register: slave_status_output
